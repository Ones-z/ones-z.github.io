<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>pretty_errors,给你的调试高亮</title>
      <link href="/2023/09/11/Fastapi/pretty-errors/"/>
      <url>/2023/09/11/Fastapi/pretty-errors/</url>
      
        <content type="html"><![CDATA[<h1 id="pretty-errors"><a href="#pretty-errors" class="headerlink" title="pretty_errors"></a>pretty_errors</h1><blockquote><p>python第三方组件，美化python错误</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install pretty-errors</span><br></pre></td></tr></table></figure><h2 id="局部使用"><a href="#局部使用" class="headerlink" title="局部使用"></a>局部使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pretty-errors</span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span>/<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="/.io//error.png" alt="局部使用"></p><h2 id="全局使用"><a href="#全局使用" class="headerlink" title="全局使用"></a>全局使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pretty_errors</span><br></pre></td></tr></table></figure><h2 id="取消使用"><a href="#取消使用" class="headerlink" title="取消使用"></a>取消使用</h2><p>只需要再次输入 python -m pretty_errors，然后输入 C 即可清除。</p><h2 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pretty_errors</span><br><span class="line"></span><br><span class="line"><span class="comment"># 【重点】进行配置</span></span><br><span class="line">pretty_errors.configure(</span><br><span class="line">    separator_character = <span class="string">&#x27;*&#x27;</span>,</span><br><span class="line">    filename_display    = pretty_errors.FILENAME_EXTENDED,</span><br><span class="line">    line_number_first   = <span class="literal">True</span>,</span><br><span class="line">    display_link        = <span class="literal">True</span>,</span><br><span class="line">    lines_before        = <span class="number">5</span>,</span><br><span class="line">    lines_after         = <span class="number">2</span>,</span><br><span class="line">    line_color          = pretty_errors.RED + <span class="string">&#x27;&gt; &#x27;</span> + pretty_errors.default_config.line_color,</span><br><span class="line">    code_color          = <span class="string">&#x27;  &#x27;</span> + pretty_errors.default_config.line_color,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Fastapi </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>依赖注入，给你的代码润色</title>
      <link href="/2023/09/11/Fastapi/dependency/"/>
      <url>/2023/09/11/Fastapi/dependency/</url>
      
        <content type="html"><![CDATA[<h1 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h1><blockquote><p>依赖注入是指在编程中，为了保证功能的使用，先导入或声明所需依赖，如子函数、数据库连接等。<br>依赖注入是一种设计模式，用于降低程序组件之间的耦合度。它通过将组件之间的依赖关系从代码中分离出来，使得组件可以更加灵活地被替换、修改或重用。</p></blockquote><h2 id="使用依赖注入的优势"><a href="#使用依赖注入的优势" class="headerlink" title="使用依赖注入的优势"></a>使用依赖注入的优势</h2><p>提高代码的复用率：</p><ul><li>共享数据库连接</li><li>增强安全、认证和角色管理</li><li>响应数据注入，可以在原来的响应数据基础上再做出更改，如抽出公用函数，在公用函数中对数据处理</li></ul><h2 id="如何使用依赖注入"><a href="#如何使用依赖注入" class="headerlink" title="如何使用依赖注入"></a>如何使用依赖注入</h2><h3 id="添加到函数"><a href="#添加到函数" class="headerlink" title="添加到函数"></a>添加到函数</h3><h4 id="函数作为依赖"><a href="#函数作为依赖" class="headerlink" title="函数作为依赖"></a>函数作为依赖</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">common_parameters</span>(<span class="params">q: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>, page: <span class="built_in">int</span> = <span class="number">1</span>, limit: <span class="built_in">int</span> = <span class="number">100</span></span>):</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;q&quot;</span>: q, <span class="string">&quot;page&quot;</span>: page, <span class="string">&quot;limit&quot;</span>: limit&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/dependency01&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">dependency01</span>(<span class="params">commons: <span class="built_in">dict</span> = Depends(<span class="params">common_parameters</span>)</span>):</span><br><span class="line">    <span class="keyword">return</span> commons</span><br></pre></td></tr></table></figure><h4 id="类作为依赖"><a href="#类作为依赖" class="headerlink" title="类作为依赖"></a>类作为依赖</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fake_items_db = [&#123;<span class="string">&quot;item_name&quot;</span>: <span class="string">&quot;Foo&quot;</span>&#125;, &#123;<span class="string">&quot;item_name&quot;</span>: <span class="string">&quot;Bar&quot;</span>&#125;, &#123;<span class="string">&quot;item_name&quot;</span>: <span class="string">&quot;Baz&quot;</span>&#125;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CommonQueryParams</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, q: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>, page: <span class="built_in">int</span> = <span class="number">1</span>, limit: <span class="built_in">int</span> = <span class="number">100</span></span>):</span><br><span class="line">        self.q = q</span><br><span class="line">        self.page = page</span><br><span class="line">        self.limit = limit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/classes_as_dependencies&quot;</span></span>)</span></span><br><span class="line"><span class="comment"># async def classes_as_dependencies(commons: CommonQueryParams = Depends(CommonQueryParams)):</span></span><br><span class="line"><span class="comment"># async def classes_as_dependencies(commons: CommonQueryParams = Depends()):</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">classes_as_dependencies</span>(<span class="params">commons=Depends(<span class="params">CommonQueryParams</span>)</span>):</span><br><span class="line">    response = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> commons.q:</span><br><span class="line">        response.update(&#123;<span class="string">&quot;q&quot;</span>: commons.q&#125;)</span><br><span class="line">    items = fake_items_db[commons.page: commons.page + commons.limit]</span><br><span class="line">    response.update(&#123;<span class="string">&quot;items&quot;</span>: items&#125;)</span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><h4 id="多层嵌套依赖"><a href="#多层嵌套依赖" class="headerlink" title="多层嵌套依赖"></a>多层嵌套依赖</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">q: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">return</span> q</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub_query</span>(<span class="params">q: <span class="built_in">str</span> = Depends(<span class="params">query</span>), last_query: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> q:</span><br><span class="line">        <span class="keyword">return</span> last_query</span><br><span class="line">    <span class="keyword">return</span> q</span><br><span class="line"></span><br><span class="line"><span class="meta">@app05.get(<span class="params"><span class="string">&quot;/sub_dependency&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">sub_dependency</span>(<span class="params">final_query: <span class="built_in">str</span> = Depends(<span class="params">sub_query, use_cache=<span class="literal">True</span></span>)</span>):</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;sub_dependency&quot;</span>: final_query&#125;</span><br></pre></td></tr></table></figure><p>use_cache默认是True, 表示当多个依赖有一个共同的子依赖时，每次request请求只会调用子依赖一次，多次调用将从缓存中获取</p><h4 id="路径操作装饰器依赖"><a href="#路径操作装饰器依赖" class="headerlink" title="路径操作装饰器依赖"></a>路径操作装饰器依赖</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">verify_token</span>(<span class="params">x_token: <span class="built_in">str</span> = Header(<span class="params">...</span>)</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;没有返回值的子依赖&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> x_token != <span class="string">&quot;aaa&quot;</span>:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">400</span>, detail=<span class="string">&quot;X-Token header invalid&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">verify_key</span>(<span class="params">x_key: <span class="built_in">str</span> = Header(<span class="params">...</span>)</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;有返回值的子依赖，但是返回值不会被调用&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> x_key != <span class="string">&quot;bbb&quot;</span>:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">400</span>, detail=<span class="string">&quot;X-Key header invalid&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> x_key</span><br><span class="line"></span><br><span class="line"><span class="meta">@app05.get(<span class="params"><span class="string">&quot;/dependency_in_path_operation&quot;</span>, dependencies=[Depends(<span class="params">verify_token</span>), Depends(<span class="params">verify_key</span>)]</span>)  </span><span class="comment"># 这时候不是在函数参数中调用依赖，而是在路径操作中</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">dependency_in_path_operation</span>():</span><br><span class="line">    <span class="keyword">return</span> [&#123;<span class="string">&quot;user&quot;</span>: <span class="string">&quot;user01&quot;</span>&#125;, &#123;<span class="string">&quot;user&quot;</span>: <span class="string">&quot;user02&quot;</span>&#125;]</span><br></pre></td></tr></table></figure><h4 id="yield依赖和子依赖"><a href="#yield依赖和子依赖" class="headerlink" title="yield依赖和子依赖"></a>yield依赖和子依赖</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_db_AsyncSession</span>() -&gt; AsyncSession:</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> AsyncSessionLocal() <span class="keyword">as</span> AsyncSession:</span><br><span class="line">        <span class="keyword">yield</span> AsyncSession</span><br><span class="line"></span><br><span class="line">DB: AsyncSession = Depends(get_db_AsyncSession)</span><br><span class="line"></span><br><span class="line"><span class="meta">@router.get(<span class="params"><span class="string">&quot;/remove/&#123;id&#125;&quot;</span>, summary=<span class="string">&quot;删除应用&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">delApp</span>(<span class="params"><span class="built_in">id</span>: <span class="built_in">int</span>, db=DB</span>):</span><br><span class="line">    data = <span class="keyword">await</span> appCrud.remove(db, <span class="built_in">id</span>)</span><br><span class="line">    <span class="keyword">return</span> BaseResponse.success(data)</span><br></pre></td></tr></table></figure><h3 id="添加到组件"><a href="#添加到组件" class="headerlink" title="添加到组件"></a>添加到组件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app = APIRouter(dependencies=[Depends(verify_token), Depends(verify_key)])</span><br></pre></td></tr></table></figure><h3 id="添加到主程序"><a href="#添加到主程序" class="headerlink" title="添加到主程序"></a>添加到主程序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app = FastAPI(dependencies=[Depends(verify_token), Depends(verify_key)]）</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Fastapi </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>你所需要了解关于高并发的常识</title>
      <link href="/2023/09/11/Python/concurrency/"/>
      <url>/2023/09/11/Python/concurrency/</url>
      
        <content type="html"><![CDATA[<h1 id="多进程、多线程、协程"><a href="#多进程、多线程、协程" class="headerlink" title="多进程、多线程、协程"></a>多进程、多线程、协程</h1><h2 id="它们的区别"><a href="#它们的区别" class="headerlink" title="它们的区别"></a>它们的区别</h2><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><ul><li>每个进程都有自己独立的内存空间，相互之间不会干扰。进程是操作系统分配资源的最小单位。</li><li>多进程适合于CPU密集型任务，可以利用多核处理器的优势，并且进程之间可以并行执行。</li><li>由于进程之间需要切换上下文，因此进程间通信比较复杂，需要使用特定的方法（如队列、管道等）。</li></ul><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><ul><li>线程是进程内的执行单位，共享进程的内存空间。多个线程共享同一进程的资源。</li><li>多线程适合于I&#x2F;O密集型任务，可以在等待I&#x2F;O操作时切换到其他线程，提高效率。</li><li>由于使用全局解释器锁（GIL），Python 的多线程无法充分利用多核处理器的优势。在 CPU 密集型任务中，多线程可能不如多进程效果好。</li></ul><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><ul><li>协程是一种用户级的轻量级线程，由用户控制切换的时机。协程可以在一个线程中实现并发。</li><li>协程通过 yield 关键字进行挂起和恢复，可以在不同的协程之间切换执行，避免了线程切换的开销。</li><li>协程适合于高并发的网络编程或异步任务，在I&#x2F;O密集型场景中效果非常好。通过使用异步框架（如asyncio）、生成器或第三方库（如gevent）来实现</li></ul><p>多进程通常使用进程对象和队列来实现进程间的数据传递和同步。多线程通常使用线程对象和锁来实现线程间的同步与通信。协程通常使用异步async&#x2F;等待await关键字和事件循环来定义和管理协程。</p><h2 id="CPU密集型任务和I-O密集型任务"><a href="#CPU密集型任务和I-O密集型任务" class="headerlink" title="CPU密集型任务和I&#x2F;O密集型任务"></a>CPU密集型任务和I&#x2F;O密集型任务</h2><ul><li>CPU密集型任务（CPU-bound）： CPU密集型任务指的是任务主要消耗CPU资源的计算任务。这些任务通常需要大量的CPU运算，例如复杂的数学计算、图像&#x2F;视频处理、科学模拟等。在这种任务中，CPU的计算能力是影响任务执行速度的主要瓶颈，而I&#x2F;O操作相对较少。</li><li>I&#x2F;O密集型任务（I&#x2F;O-bound）： I&#x2F;O密集型任务指的是任务主要消耗I&#x2F;O资源的任务。这些任务通常需要频繁地进行输入&#x2F;输出操作，如磁盘读写、网络通信、数据库访问等。在这种任务中，任务的执行速度主要受限于I&#x2F;O操作的速度，而CPU的计算能力相对较少成为瓶颈。</li></ul><h2 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h2><h3 id="全局解释器锁（GIL）"><a href="#全局解释器锁（GIL）" class="headerlink" title="全局解释器锁（GIL）"></a>全局解释器锁（GIL）</h3><p>简单来说，是一种互斥锁（或锁），只允许一个线程控制 Python 解释器。<br>这意味着在任何时间点只有一个线程可以处于执行状态。GIL 的影响对于执行单线程程序的开发人员来说是不可见的，但它可能是 CPU 密集型和多线程代码中的性能瓶颈。</p><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>线程安全是多线程或多进程编程中的一个概念，在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。</p><h3 id="锁的作用"><a href="#锁的作用" class="headerlink" title="锁的作用"></a>锁的作用</h3><blockquote><p>锁是Python提供给我们能够自行操控线程切换的一种手段，使用锁可以让线程的切换变的有序。<br>一旦线程的切换变的有序后，各个线程之间对数据的访问、修改就变的可控，所以若要保证线程安全，就必须使用锁。</p></blockquote><p>threading模块中提供了5种最常见的锁，下面是按照功能进行划分：</p><ul><li>同步锁：lock（一次只能放行一个）</li><li>递归锁：rlock（一次只能放行一个）</li><li>条件锁：condition（一次可以放行任意个）</li><li>事件锁：event（一次全部放行）</li><li>信号量锁：semaphore（一次可以放行特定个）</li></ul><h3 id="同步锁Lock"><a href="#同步锁Lock" class="headerlink" title="同步锁Lock"></a>同步锁Lock</h3><ol><li>互斥指的是某一资源同一时刻仅能有一个访问者对其进行访问，具有唯一性和排他性，但是互斥无法限制访问者对资源的访问顺序，即访问是无序的</li><li>同步是指在互斥的基础上（大多数情况），通过其他机制实现访问者对资源的有序访问</li><li>同步其实已经实现了互斥，是互斥的一种更为复杂的实现，因为它在互斥的基础上实现了有序访问的特点</li></ol><h3 id="死锁现象"><a href="#死锁现象" class="headerlink" title="死锁现象"></a>死锁现象</h3><p>对于同步锁来说，一次acquire()必须对应一次release()，不能出现连续重复使用多次acquire()后再重复使用多次release()的操作，这样会引起死锁造成程序的阻塞，完全不动了<br>由于threading.Lock()对象中实现了enter__()与__exit()方法，故我们可以使用with语句进行上下文管理形式的加锁解锁操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>():</span><br><span class="line">    <span class="keyword">with</span> lock:</span><br><span class="line">        <span class="comment"># 自动加锁</span></span><br><span class="line">        <span class="keyword">global</span> num</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10_000_000</span>):</span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 自动解锁</span></span><br></pre></td></tr></table></figure><h3 id="递归锁RLock"><a href="#递归锁RLock" class="headerlink" title="递归锁RLock"></a>递归锁RLock</h3><p>递归锁是同步锁的一个升级版本，在同步锁的基础上可以做到连续重复使用多次acquire()后再重复使用多次release()的操作，但是一定要注意加锁次数和解锁次数必须一致，否则也将引发死锁现象。</p><h3 id="条件锁Condition"><a href="#条件锁Condition" class="headerlink" title="条件锁Condition"></a>条件锁Condition</h3><p>条件锁是在递归锁的基础上增加了能够暂停线程运行的功能。并且我们可以使用wait()与notify()来控制线程执行的个数。</p><h3 id="事件锁Event"><a href="#事件锁Event" class="headerlink" title="事件锁Event"></a>事件锁Event</h3><p>事件锁是基于条件锁来做的，它与条件锁的区别在于一次只能放行全部，不能放行任意个数量的子线程继续运行。<br>我们可以将事件锁看为红绿灯，当红灯时所有子线程都暂停运行，并进入“等待”状态，当绿灯时所有子线程都恢复“运行”。</p><h3 id="信号量锁Semaphore"><a href="#信号量锁Semaphore" class="headerlink" title="信号量锁Semaphore"></a>信号量锁Semaphore</h3><p>信号量锁也是根据条件锁来做的，它与条件锁和事件锁的区别如下：</p><ul><li>条件锁：一次可以放行任意个处于“等待”状态的线程</li><li>事件锁：一次可以放行全部的处于“等待”状态的线程</li><li>信号量锁：通过规定，成批的放行特定个处于“上锁”状态的线程</li></ul><h2 id="协程-1"><a href="#协程-1" class="headerlink" title="协程"></a>协程</h2><p>定义协程的方式：</p><ol><li>通过async def定义且通过return返回值的函数为协程函数。协程函数的返回对象称为协程对象，是可等待对象的一种。</li><li>协程对象由await或asyncio.run()进行驱动，await只能用于async def定义的函数体中。</li><li>asyncio.gather()用来并发运行可等待对象序列。</li><li>通过async def定义且通过yield返回值的函数为协程生成器，可以用async for来进行迭代。</li><li>能够被await驱动的对象类型称为awaitable，即可等待对象。在Python标准库中，定义了特殊方法__await__()的对象都是可等待对象，主要有三类：coroutine，Task，Future。其中，coroutine就是协程函数的返回对象；Task为asycio.create_task(coroutine)的返回对象。</li><li>不使用await或asyncio.run驱动，而是直接调用协程函数，则协程函数会返回一个协程对象。</li></ol><p>从执行结果可以观察到很重要的一点：被驱动的协程对象都是立即返回，尽管最终的结果还未得到。其实协程本质上只是在用户程序和低层线程之间搭建了一个”管道“，从而把协程调度的工作委派了事件循环。我们不需要知道低层的运作原理，我们只需要确保在我们的代码中没有阻塞的代码，事件循环会在背后替我们处理并发。</p><p>引用自协程相比多线程有两点优势：</p><ol><li>没有线程切换的开销。</li><li>因为协程都是运行在一个线程上的，不存在由于多线程的”竞争机制“导致的同时写变量冲突等问题。因此，在协程中对于共享资源不需要加锁。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深拷贝与浅拷贝，你知道区别吗</title>
      <link href="/2023/09/11/Python/copy/"/>
      <url>/2023/09/11/Python/copy/</url>
      
        <content type="html"><![CDATA[<h1 id="深拷贝和浅拷贝的区别"><a href="#深拷贝和浅拷贝的区别" class="headerlink" title="深拷贝和浅拷贝的区别"></a>深拷贝和浅拷贝的区别</h1><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><blockquote><p>浅拷贝创建一个新对象，该对象与原始对象共享内部的可变对象的引用。简而言之，浅拷贝只复制了对象的顶层元素，而没有复制内部的嵌套对象。当对嵌套对象进行修改时，原始对象和浅拷贝对象都会受到影响</p></blockquote><h3 id="使用copy-函数执行浅拷贝"><a href="#使用copy-函数执行浅拷贝" class="headerlink" title="使用copy()函数执行浅拷贝"></a>使用copy()函数执行浅拷贝</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">list2 = copy.copy(list1)  <span class="comment"># 执行浅拷贝</span></span><br><span class="line"></span><br><span class="line">list2[<span class="number">2</span>].append(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(list1)  <span class="comment"># 输出: [1, 2, [3, 4, 5]]</span></span><br><span class="line"><span class="built_in">print</span>(list2)  <span class="comment"># 输出: [1, 2, [3, 4, 5]]</span></span><br></pre></td></tr></table></figure><h3 id="或使用切片操作符-进行浅拷贝"><a href="#或使用切片操作符-进行浅拷贝" class="headerlink" title="或使用切片操作符[:]进行浅拷贝"></a>或使用切片操作符[:]进行浅拷贝</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">list2 = list1[<span class="number">1</span>:] <span class="comment"># 执行深拷贝</span></span><br><span class="line"></span><br><span class="line">list2[<span class="number">1</span>].append(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(list1)  <span class="comment"># 输出: [1, 2, [3, 4, 5]]</span></span><br><span class="line"><span class="built_in">print</span>(list2)  <span class="comment"># 输出: [2, [3, 4, 5]]</span></span><br></pre></td></tr></table></figure><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><blockquote><p>深拷贝创建一个新对象，并递归地复制所有嵌套对象，而不仅仅是顶层元素。深拷贝使得原始对象和拷贝对象完全独立，彼此之间的修改互不影响。</p></blockquote><h3 id="使用deepcopy-函数可以执行深拷贝"><a href="#使用deepcopy-函数可以执行深拷贝" class="headerlink" title="使用deepcopy()函数可以执行深拷贝"></a>使用deepcopy()函数可以执行深拷贝</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">list2 = copy.deepcopy(list1)  <span class="comment"># 执行深拷贝</span></span><br><span class="line"></span><br><span class="line">list2[<span class="number">2</span>].append(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(list1)  <span class="comment"># 输出: [1, 2, [3, 4]]</span></span><br><span class="line"><span class="built_in">print</span>(list2)  <span class="comment"># 输出: [1, 2, [3, 4, 5]]</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>解包有哪些骚操作</title>
      <link href="/2023/09/11/Python/unpack/"/>
      <url>/2023/09/11/Python/unpack/</url>
      
        <content type="html"><![CDATA[<h1 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h1><blockquote><p>在 Python 中，解包（Unpacking）是指将可迭代对象（例如列表、元组、集合等）中的元素一一分配给变量的过程。解包可以使得代码更加简洁和可读，并且可以同时对多个变量进行赋值。</p></blockquote><h2 id="基本解包"><a href="#基本解包" class="headerlink" title="基本解包"></a>基本解包</h2><blockquote><p>将可迭代对象中的元素按顺序赋值给对应数量的变量。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x, y, z = (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(x,y,z)    <span class="comment">#&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="扩展解包"><a href="#扩展解包" class="headerlink" title="扩展解包"></a>扩展解包</h2><blockquote><p>使用 * 运算符将可迭代对象中的剩余元素解包为一个列表。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x, *y, z = (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>)  <span class="comment"># x=&#x27;a&#x27;, y=[&#x27;b&#x27;, &#x27;c&#x27;], z=&#x27;d&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="忽略特定元素"><a href="#忽略特定元素" class="headerlink" title="忽略特定元素"></a>忽略特定元素</h2><blockquote><p>使用 _ 或其他不需要的变量名来标识不关心的元素。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x, *_ = (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)  <span class="comment"># x=&#x27;a&#x27;，其余的元素被忽略</span></span><br></pre></td></tr></table></figure><h2 id="嵌套解包"><a href="#嵌套解包" class="headerlink" title="嵌套解包"></a>嵌套解包</h2><blockquote><p>对嵌套的可迭代对象进行解包，可以同时解开多层嵌套。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x, *y, (z, w) = (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, (<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>))  <span class="comment"># x=&#x27;a&#x27;, y=[&#x27;b&#x27;, &#x27;c&#x27;], z=&#x27;d&#x27;, w=&#x27;e&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="args"><a href="#args" class="headerlink" title="*args"></a>*args</h2><blockquote><p>*args 将接收解包后的参数作为一个元组，在函数内部可以遍历和处理这些参数。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">point</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="built_in">print</span>(x,y)</span><br><span class="line">foo_list = <span class="string">&#x27;12&#x27;</span></span><br><span class="line">point(*foo_list)     <span class="comment">#1 2</span></span><br></pre></td></tr></table></figure><h2 id="kw"><a href="#kw" class="headerlink" title="**kw"></a>**kw</h2><blockquote><p>**kw 是一种在函数定义和函数调用中处理关键字参数的语法。它允许你在函数内部以字典的方式访问和操作这些参数。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">point</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="built_in">print</span>(x,y)</span><br><span class="line">foo_list = &#123;<span class="string">&#x27;x&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;y&#x27;</span>:<span class="number">2</span>&#125;</span><br><span class="line">point(**foo_list)    <span class="comment">#1 2</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>神奇的语法糖</title>
      <link href="/2023/09/11/Python/sugar/"/>
      <url>/2023/09/11/Python/sugar/</url>
      
        <content type="html"><![CDATA[<h1 id="精简却功能强大的语法糖"><a href="#精简却功能强大的语法糖" class="headerlink" title="精简却功能强大的语法糖"></a>精简却功能强大的语法糖</h1><h2 id="三元表达式"><a href="#三元表达式" class="headerlink" title="三元表达式"></a>三元表达式</h2><blockquote><p>在Python中，三元表达式的形式为 value_if_true if condition else value_if_false。这种表达式的作用是根据条件的真假选择两个值中的一个作为整个表达式的结果。<br>使用三元表达式可以简化某些条件判断的语法，并且可以在一行中完成相应的逻辑操作。这在某些情况下可以提高代码的可读性和简洁性。</p></blockquote><h3 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span> <span class="keyword">if</span> x&gt;<span class="number">2</span> esle x)   <span class="comment">#2</span></span><br></pre></td></tr></table></figure><h3 id="布尔索引"><a href="#布尔索引" class="headerlink" title="布尔索引"></a>布尔索引</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a,b=<span class="number">10</span>,<span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>((b, a) [a &lt; b])   <span class="comment">#20</span></span><br></pre></td></tr></table></figure><h3 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>([i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(x)])   <span class="comment">#[0,1,2,3,4,5,6,7,8,9]</span></span><br></pre></td></tr></table></figure><h3 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(&#123;i:i+<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(x)&#125;)   <span class="comment">#&#123;0: 1, 1: 2, 2: 3, 3: 4, 4: 5&#125;</span></span><br></pre></td></tr></table></figure><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>((i:i+<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(x)))   <span class="comment">#&lt;generator object &lt;genexpr&gt; at 0x101ed0820&gt;</span></span><br></pre></td></tr></table></figure><h3 id="在字典应用"><a href="#在字典应用" class="headerlink" title="在字典应用"></a>在字典应用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">22</span></span><br><span class="line">person_info = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: age,</span><br><span class="line">    <span class="string">&quot;category&quot;</span>: <span class="string">&quot;Adult&quot;</span> <span class="keyword">if</span> age &gt;= <span class="number">18</span> <span class="keyword">else</span> <span class="string">&quot;Child&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(person_info)   <span class="comment"># &#123;&#x27;name&#x27;: &#x27;John&#x27;, &#x27;age&#x27;: 22, &#x27;category&#x27;: &#x27;Adult&#x27;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="嵌套条件判断"><a href="#嵌套条件判断" class="headerlink" title="嵌套条件判断"></a>嵌套条件判断</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a, b = <span class="number">10</span>, <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;1&quot;</span> <span class="keyword">if</span> a == b <span class="keyword">else</span> <span class="string">&quot;2&quot;</span> <span class="keyword">if</span> a &gt; b <span class="keyword">else</span> <span class="string">&quot;3&quot;</span>)   <span class="comment">#3</span></span><br></pre></td></tr></table></figure><h3 id="结合lambda"><a href="#结合lambda" class="headerlink" title="结合lambda"></a>结合lambda</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>((<span class="keyword">lambda</span> x:x+<span class="number">1</span> <span class="keyword">if</span> x&gt;<span class="number">4</span> <span class="keyword">else</span> x)(x))   <span class="comment">#6</span></span><br></pre></td></tr></table></figure><h3 id="结合print"><a href="#结合print" class="headerlink" title="结合print"></a>结合print</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(x) <span class="keyword">if</span> x &gt;<span class="number">4</span> <span class="keyword">else</span> <span class="built_in">print</span>(x-<span class="number">1</span>)   <span class="comment">#5</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>特立独行的运算符</title>
      <link href="/2023/09/11/Python/operators/"/>
      <url>/2023/09/11/Python/operators/</url>
      
        <content type="html"><![CDATA[<h1 id="高效的运算符"><a href="#高效的运算符" class="headerlink" title="高效的运算符"></a>高效的运算符</h1><h2 id="链式比较"><a href="#链式比较" class="headerlink" title="链式比较"></a>链式比较</h2><h3 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">5</span></span><br><span class="line">ans=<span class="number">1</span>&lt;i&lt;<span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(ans)    <span class="comment">#True</span></span><br></pre></td></tr></table></figure><h3 id="合集"><a href="#合集" class="headerlink" title="合集"></a>合集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">5</span></span><br><span class="line">ans=<span class="number">10</span>&gt;i&lt;=<span class="number">9</span></span><br><span class="line"><span class="built_in">print</span>(ans)    <span class="comment">#True</span></span><br></pre></td></tr></table></figure><h2 id="合并字典"><a href="#合并字典" class="headerlink" title="合并字典"></a>合并字典</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line">dict2 = &#123;<span class="string">&quot;c&quot;</span>: <span class="number">3</span>, <span class="string">&quot;d&quot;</span>: <span class="number">4</span>&#125;</span><br><span class="line"> </span><br><span class="line">merged_dict = dict1 | dict2</span><br><span class="line"><span class="built_in">print</span>(merged_dict)    <span class="comment">#&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
